--- 
layout: post
title: "#4 Metaprograma\xC3\xA7\xC3\xA3o: Blocos"
tags: 
- "metaprograma\xC3\xA7\xC3\xA3o"
- oo
- ruby
status: publish
type: post
published: true
meta: 
  _edit_last: "597486"
image: meta4  
---
<em>Obs: Esse post assume que você conhece o básico sobre blocos em Ruby.</em>

<a href="http://andersonleiteblog.files.wordpress.com/2010/02/lego-art-lego-bricks.jpg"><img src="http://andersonleiteblog.files.wordpress.com/2010/02/lego-art-lego-bricks.jpg" alt="" title="lego-art-lego-bricks" width="450" height="337" class="aligncenter size-full wp-image-526" /></a>

Um código precisa de um ambiente pra ser executado, que pode ser
uma variável local, variável de instância, self...

O nome dado para essas entidades normalmente é <b>binding</b>. A característica principal dos blocos é que eles contém tanto o código a ser executado quanto os <b>bindings</b>.

Vejamos esse exemplo. Um método <strong>imprime_cor</strong> passando um bloco. Antes disso, uma variável x definida como "Azul". A variável se encontra <b>no mesmo escopo</b> da chamada do método:

<a href="http://andersonleiteblog.files.wordpress.com/2010/02/picture-14.png"><img src="http://andersonleiteblog.files.wordpress.com/2010/02/picture-14.png" alt="" title="Picture 1" width="423" height="169" class="aligncenter size-full wp-image-527" /></a>

Qual será a resposta ? Quando você passa um bloco para um método, eles tem um conjunto de <b>bindings</b> diferentes entre si.
No escopo do método, a variável x vale "Vermelho". No escopo do bloco a variável  x vale "Azul".  Não existe algo como sobrescrita aqui! <b>Os escopos são diferentes</b>, o que faz com que o código no método não seja visível ao bloco.  
<i>Resposta: Azul</i>
  
Essa propriedade é chamada de <strong>closure</strong>, o importante aqui é que o bloco captura seu conjunto de bindings e leva consigo por onde for.

Vamos entender um pouco mais sobre os <strong>Escopos (Scopes)</strong>.

<blockquote>Scopes</blockquote>

De acordo com o escopo atual, voce terá dierentes <strong>bindings</strong>. O objeto atual que ve os escopos é também conhecido como <b>self</b>. Vamos analisar os bindings em diferentes escopos com a ajuda do método <b>Kernel#local_variables( )</b>.


   <a href="http://andersonleiteblog.files.wordpress.com/2010/02/picture-24.png"><img src="http://andersonleiteblog.files.wordpress.com/2010/02/picture-24.png" alt="" title="Picture 2" width="437" height="361" class="aligncenter size-full wp-image-528" /></a>
  
O primeiro escopo, ainda fora da classe é chamado de <b>top-level scope</b> e define a variável v1. Então ele entra no escopo da classe, e o que ocorre ?
  
Sempre que você entra em um novo escopo os bindings anteriores são substituídos por um novo conjunto de bindings, o que significa que quando o programa entra na classe, v1 saiu do escopo e não é mais visível.

E quanto ao escopo do método? Enquanto o método não for chamado, seu escopo não existe.

Essa análise é mais fácil de ser feita conhecendo as <strong>barreiras dos escopos (Scope Gates)</strong>. 

<blockquote>Scope Gates </blockquote>

Existem 3 lugares que Ruby deixa o escopo anterior e cria um novo:
        

<ul>
   	<li>Classes (class)</li>

	<li>Módulos (module)</li>

	<li>Métodos (def)</li>

</ul>

<a href="http://andersonleiteblog.files.wordpress.com/2010/02/bridge81.jpg"><img src="http://andersonleiteblog.files.wordpress.com/2010/02/bridge81.jpg?w=300" alt="" title="bridge8" width="300" height="225" class="aligncenter size-medium wp-image-538" /></a>
    
A diferença sutil está entre classes/modulos e métodos. Códigos em classes e módulos são executados imediatamente enquanto códigos em métodos são executados eventualmente de acordo com a chamada a eles.    

<blockquote>Flattening the Scope</blockquote>


Existe um maneira de "burlar" e passar pelas barreiras dos escopos, vejamos o código abaixo:
    
    
<a href="http://andersonleiteblog.files.wordpress.com/2010/02/picture-33.png"><img src="http://andersonleiteblog.files.wordpress.com/2010/02/picture-33.png" alt="" title="Picture 3" width="394" height="204" class="aligncenter size-full wp-image-529" /></a>
    
O problema é que a cada vez que você entra em um novo escopo, as variáveis antigas somem do escopo anterior...então como passar a variável ?
      
A primeira barreira é a <strong>class</strong>. Quando a classe aparece um novo escopo é criado. Porém.. se a chamada a classe fosse através de um metodo ela estaria no mesmo escopo. Você pode capturar a variável e passar esse <strong>closure</strong> ao método. Como? Criar uma classe é o mesmo que chamar seu método <b>new</b>! 
      
A mesma estratégia pode ser utilizada com o método, também passando o clousure:
      
<a href="http://andersonleiteblog.files.wordpress.com/2010/02/picture-43.png"><img src="http://andersonleiteblog.files.wordpress.com/2010/02/picture-43.png" alt="" title="Picture 4" width="453" height="284" class="aligncenter size-full wp-image-530" /></a>

Essa estratégia é também conhecida como <b>nested lexical scopes</b>, <b>ﬂattening the scope</b>, ou apenas <b>Flat Scope</b>.
      
<strong>Continua</strong>
Próximo post - <a href="http://andersonleiteblog.wordpress.com/2010/02/18/metaprogramacao-procs-lambdas-e/">Procs, lambdas e &amp;</a>


      
      
      

--- 
layout: post
title: Testable classes don't seek, but receive
tags: 
- android
status: publish
type: post
published: true
image: test
---

<strong>An Android example on how to use Dependency Injection with Dagger and mock dependencies in JUnit with Mockito</strong>
<br><br>

There is a phenomenon in Hollywood from the clich√© response given to amateurs auditioning: "Don't call us, we'll call you". My friend Mauricio Aniche wrote a <a href="http://www.aniche.com.br/classes-testaveis-nao-buscam-mas-sim-recebem/">great post about how to use this concept</a> in order to have better unit tests.
<br><br>

We're going to apply here the same code he wrote. In a pratical way, let's understand how to use the <a href="http://martinfowler.com/bliki/InversionOfControl.html">Inversion of Control</a> pattern in Android applications.
<br><br>

<b>Warming up: The Scenario</b>
<br><br>

We have a <span>BillFilter</span> responsible for <span>filter</span>
bills that have value less then 2000. This class will receive the BillDao in the 
constructor.
<br><br>

{% gist 71669f8c45e8696f3597 %}

Our <span>BillDao</span> will connect to the database. The <span>BillFIlter</span> will be responsible for the logic of getting just the values with less then 2000 values. The <span>BillFilter</span> will receive <span>BillDao</span> as a parameter in the constructor. The <span>MainActivity</span> will get the number and show in the screen.

<center><img width="500px" src="/images/hollywood.png"></center>
<br><br>

<b>Dependency Injection with Dagger 2 </b>
<br><br>

As you can see in the first code above, BillFilter's constructor has now <span>@Inject</span> annotation. This comes from <a href="https://www.jcp.org/en/jsr/detail?id=330">JSR-330</a> specification and will be implemented with <a href="http://google.github.io/dagger/">Dagger 2</a> in this example. 
<br><br>

In order to have this injection working properly, we need to teach Dagger what to inject when constructin the graph. For this, we'll need to use 2 components of the framework:

<ul>
	<li>&#10097; Module: To teach how to provide one dependency</li>
	<li>&#10097; Component: Tie everything together and return full loaded object</li>
</ul>

{% gist 12af215981682896b98e %}

With this classes, <span>Dagger</span> will look the dependency in the BIllFilter constructor and search for a methods annotated with <span>@Provides</span>. Component is the class we will use when we need a BillFilter from now on.
<br><br>

<b>The Activity</b>
<br><br>

The activity now will be very simple. The idea is just to use fully loaded <span>BillComponent</span> and receive the filtered bills with ther filter method. We then update the TextView with the list size.
<br><br>

{% gist e4c3c226cdc55b663188 %}

<b>Finally, we can easily test</b>
<br><br>

The main idea here was <span>to receive dependencies as parameters</span>, for example, in the constructor. This way we can achive <span>loose coupling in our design and unitarily test</span> our bussiness logic.
<br><br>

In the test bellow, everything we want is to make sure the filter method will every works as expected. Here comes <span>Mockito</span>. Benefited from the idea of receiving the <span>BillDao</span> dependency in the constructor, we will mock BillDao and stub the <span>all()</span> method to return a controled list. This way, we don't need a database to unit test the scenario.
<br><br>

{% gist 6b8b573e0563e2592cd8 %}

<b>Don't seek, receive</b>
<br><br>

Using the idea of receiving dependencies you can easily make your code more testable. To achive that, try to use a framework like Dagger or any one else.
The most important concept here, as explaind in the post, is to have a good classes design in order to have good and maintainable software.
<br><br>
<center><img width="300px" src="http://themouette.github.io/slides-edu-frontend/img/03/dontcallus.png"></center>

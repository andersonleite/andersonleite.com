--- 
layout: post
title: "Clojure #0"
tags: 
- clojure
status: publish
type: post
published: true
meta: 
  _edit_last: "597486"
  jabber_published: "1282375043"
  _wp_old_slug: ""
image: closure0
---
<strong>Clojure</strong> é uma linguagem dinâmica que pode rodar na JVM, possui uma syntax bem limpa e clara, é extremamente baseada em Lisp, e tem características de liguagem funcional, ou seja, estrutura de dados imutáveis tornando a maioria das funções livres de efeitos colaterais, o que torna mais fácil a escrita de programas complexos.

<a href="http://andersonleiteblog.files.wordpress.com/2010/08/clojure.png"><img src="http://andersonleiteblog.files.wordpress.com/2010/08/clojure.png" alt="" title="clojure" width="396" height="116" class="alignnone size-full wp-image-610" /></a>

Por rodar na <strong>JVM</strong>, <strong>Clojure</strong> é muito relacionado com <strong>Java</strong>. A integração é bem simples e rápida, não necessitando nenhuma camada intermediária e, ao contraário da maioria das linguagens dinâmicas, <strong>clojure</strong> é rápido pois foi justamente escrito para tirar vantagens dos poderes de otimização das <strong>JVMs</strong>, podendo ser usada para diversos propósitos.

<strong>Clojure</strong> combina idéias vindas do <strong>Lisp</strong>, da programação funcional e lida com problemas de concorrência.



<blockquote>Instalando</blockquote>



Pra ver os primeiros códigos Clojure rodando é necessário baixar o arquivo <a href="http://code.google.com/p/clojure/downloads/detail?name=clojure-1.1.0.zip">cloujure.zip</a>


Descompaacte o arquivo. Voce vai encontrar diversas pastas e arquivos, mas não se preocupe com isso agora.
Dentro dessa pasta crie um arquivo chamado<strong> clojure.clj</strong> (repare no .<strong>CLJ</strong> para arquivos clojure).
Vamos começar criando um teste ao invés do tradicional <a href="http://en.wikipedia.org/wiki/Read-eval-print_loop">REPL</a>. Não se preocupe em entender toda syntax agora, apenas vá se adaptando:
<code>
(ns clojure.test.example
  (:use clojure.test))

(deftest add-1-to-1
  (is (= 2 (+ 1 1))))

(run-all-tests)</code>

Rode no terminal com:
<code>java -cp clojure.jar clojure.main -i clojure.clj</code>

Quando tudo der certo você deve ver o seguinte output:
<code>
Testing user

Testing clojure.zip

Ran 1 tests containing 1 assertions.
0 failures, 0 errors.</code>
 




<blockquote>Mais Clojure</blockquote>


<strong>Clojure</strong> equilibra conhecimentos de linguagens do passado com poderes das linguagens atuais.
Veja o exemplo abaixo:
<code>
//Java
public class StringUtils { 
public static boolean isBlank(String str) { 
int strLen; 
if (str == null || (strLen = str.length()) == 0) { 
return true; 
} 
for (int i = 0; i &lt; strLen; i++) { 
if ((Character.isWhitespace(str.charAt(i)) == false)) { 
return false; 
} 
} 
return true; 
} 
} 


; Clojure
(defn blank? [s] (every? #(Character/isWhitespace %) s)) </code>

A versão <strong>Clojure</strong> é bem mais curta, mas o mais importante é ser mais simples. Não são necessárias nem variáveis. Isso é possível graças as chamadas "higher-order function"  (funções que aceitam outras funções como argumento e/ou retornam funções como resultado). Além disso a versão Cljure é bem legivel. É como ler "uma string é vazia se toos os caracteres nela são espaços em branco".

<code>
// java
public class Person { 
private String firstName; 
private String lastName; 
public Person(String firstName, String lastName) { 
this.firstName = firstName; 
this.lastName = lastName; 
} 
public String getFirstName() { 
return firstName; 
} 
public void setFirstName(String firstName) { 
this.firstName = firstName; 
} 
public String getLastName() { 
return lastName; 
} 
public void setLastName(String lastName) { 
this.lastName = lastName; 
} 
} 

; clojure
(defstruct person :first-name :last-name) 
</code>

<strong>Person em</strong> <strong>Clojure</strong> é imutavel (<strong>Clojure</strong> também prove implementação correta de hash_code e equals automaticamente).


<a href="http://andersonleiteblog.files.wordpress.com/2010/08/clojuratica.png"><img src="http://andersonleiteblog.files.wordpress.com/2010/08/clojuratica.png" alt="" title="clojuratica" width="360" height="425" class="alignnone size-full wp-image-613" /></a>
<blockquote>Definindo funções</blockquote>



<code>(defn hello-world [username] 
(println (format "Hello, %s" username))) </code>

<strong>Clojure</strong> é uma linguagem funcional, mas não puramente como <strong>Haskell</strong>.
Funções podem ser criadas em runtime, retornadas, e normalmente usadas como um tipo como outro qualquer.
E nos tempos atuais, programação funcional é muito mais urgente que antes, devido aos avanços de hardware.


<strong>Clojure</strong> simplifica a programação concorrente, tornando fácil escrever código thread-safe.
Como estruturas imutáveis não mudam nunca, não existe risco de dados corrompidos por terem sidos utilizados
por outras threads. Tudo isso dentro da já consagrada <strong>JVM</strong>, onde inclusive, <strong>Clojure</strong> implementa funções simples 
para uma série de interfaces <strong>Java</strong>.

Agora que já falamos sobre as características do <strong>Clojure</strong>, os próximos posts abordarão mais sobre código.

---
layout: post
title: "#6 Metaprogramação: Definindo Classes"
tags:
- "metaprograma\xC3\xA7\xC3\xA3o"
- ruby
status: publish
type: post
published: true
meta:
  _edit_last: "597486"
image: meta6
---
<strong>Algumas pessoas tem comentado que os conceitos de metaprogramação tem ajudado na quebra de paradigma de Ruby e suas linguagens anteriores, como Java ou C#.</strong>

<br /><br />
De fato as diferenças são grandes e aqui vai mais uma delas. Em linguagens como Java e C#, ao definir uma classe você está dizendo ao compilador: "<em>Ei compilador, quando eu criar um objeto desse tipo, ele deve se comportar dessa forma</em>".

<br /><br />
Em Ruby isso é diferente. Ao definir uma classe você está <span>rodando código</span>.

<br /><br />
<span>ps</span>: Tudo que for aplicado aqui em classes também é aplicável em módulos.

<br /><br />
<b>Definindo classes</b><br />
Em <span>Ruby</span>, uma classe não é um lugar onde você apenas coloca métodos. Você pode retornar valores em uma classe, como em métodos. Além disso, classes(e módulos) são muitas vezes o <span>objeto corrente (self)</span>, afinal, <span>classes também são objetos</span>.

<br /><br />
<a href="http://andersonleiteblog.files.wordpress.com/2010/02/picture-16.png"><img src="http://andersonleiteblog.files.wordpress.com/2010/02/picture-16.png?w=300" alt="" title="Picture 1" width="300" height="147" class="aligncenter size-medium wp-image-567" /></a>

<br /><br />
Em Ruby você sempre tem um objeto corrente, sempre existe o <span>self</span>, e consequentemente uma classe. Lembre-se que sempre que você define um método, <a href="http://andersonleiteblog.wordpress.com/2010/02/09/metaprogramacao-ruby-object-model/">você está definindo um método de instância</a>.

<br /><br />
Você já deve ter visto o <a href="http://andersonleiteblog.wordpress.com/2009/03/28/ruby-metaprogramacao-e-convencoes/">básico sobre adicionar métodos em tempo de execução</a>, mas existem outras formas. Uma forma importante é conhecer o método <span>class_eval</span>.

<br /><br />
Assim como o <span>instance_eval</span>, o método <span>class_eval</span> pode mudar o comportamento de um objeto corrente (<span>self</span>), mas além disso, pode mudar também o comportamento da classe de desse objeto:

<br /><br />
<a href="http://andersonleiteblog.files.wordpress.com/2010/02/picture-26.png"><img src="http://andersonleiteblog.files.wordpress.com/2010/02/picture-26.png?w=238" alt="" title="Picture 2" width="238" height="300" class="aligncenter size-medium wp-image-568" /></a>

<br /><br />
<b>Variáveis de instância da classe</b><br />

Como classes são objetos, nada proibe que a classe tenha então suas próprias variáveis de instância:

<br /><br />
<a href="http://andersonleiteblog.files.wordpress.com/2010/02/picture-35.png"><img src="http://andersonleiteblog.files.wordpress.com/2010/02/picture-35.png?w=286" alt="" title="Picture 3" width="286" height="300" class="aligncenter size-medium wp-image-569" /></a>

<br /><br />
<span>PS</span>: se voce vem do java, não confunda com static. A classe criada é uma instância da classe <a href="http://ruby-doc.org/core/classes/Class.html">Class</a>. (Vale dar uma lida nessa parte da documentação).

<br /><br />
<span>PS</span>: Esse post é uma preparação para o próximo sobre <em>singleton classes e methods</em>. Sugiro a leitura do post "<a href="http://andersonleiteblog.wordpress.com/2009/11/04/onde-posso-usar-singleton-classes/">Onde posso usar singleton classes?</a>".

<br /><br />
<a href="http://andersonleiteblog.files.wordpress.com/2010/02/25_legoman_lg.jpg"><img src="http://andersonleiteblog.files.wordpress.com/2010/02/25_legoman_lg.jpg?w=300" alt="" title="25_legoman_lg" width="300" height="200" class="aligncenter size-medium wp-image-563" /></a>

<br /><br />
<b>Continua</b><br />
Próximo post - <a href="http://andersonleiteblog.wordpress.com/2010/03/10/7-metaprogramacao-eigenclasses/">Eigenclasses</a>



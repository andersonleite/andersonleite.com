--- 
layout: post
title: jruby e jni
tags: 
- c
- java
- jni
- jruby
- ruby
- ruby java jni jruby c
status: publish
type: post
published: true
meta: 
  _edit_last: "597486"
image: jruby
---
Como fazer em ruby para buscar o processId(PID) da thread corrente ?

Em java é possível acessar de forma nativa um método em C que tem acesso a tal informação via JNI. 
E se em ruby conseguimos acessar uma classe java com JRuby, podemos conseguir esse PID.

Vamos criar a primeira parte, a implementação java que via JNI consegue o processId.

Primeiro a classe java:
<code>
class GetPid {
	public GetPid(){}
	public native long getpid ();
	static {
		System.loadLibrary("getpid");
	}
	public static void main (String[] args) {
		GetPid gp = new GetPid ();
		gp.getpid();
	}
}</code>


O método getpid é native, ou seja, será um método escrito em C.

Compilamos o GetPid.java:
<code>$ javac GetPid.java</code>

E em seguida geramos os cabeçalhos(headers) da implementação nativa:
<code>$ javah GetPid</code>

O comando acima gera o seguinte código
<code>/* DO NOT EDIT THIS FILE - it is machine generated */
#include 
/* Header for class GetPid */
#ifndef _Included_GetPid
#define _Included_GetPid
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     GetPid
 * Method:    getpid
 * Signature: ()J
 */
JNIEXPORT jlong JNICALL Java_GetPid_getpid
  (JNIEnv *, jobject);
#ifdef __cplusplus
}
#endif
#endif
</code>

Esse é apenas o cabeçalho, precisamos da implementação do método em C, no arquivo GetPid.c:
<code>
#include "getPid.h"
JNIEXPORT jlong JNICALL Java_GetPid_getpid (JNIEnv * env, jobject jobj){
	return getpid();
}
</code>

Agora vamos usar o gcc para compilar o arquivo, dependendo do seu sistema operacional a forma é diferente:

<strong>Linux</strong>
# gcc -shared -fpic -o libgetpid.so -I/usr/java/include -I/usr/java/include/linux getPid.c
<strong>Mac OSX</strong>
# gcc -dynamiclib -o libgetpid.jnilib -I/System/Library/Frameworks/JavaVM.framework/Headers GetPid.c -framework JavaVM

Agora falta fazer o link entre suas variáveis de ambiente e o Java:
<code>
$ LD_LIBRARY_PATH=.
$ export LD_LIBRARY_PATH
</code>
Se tudo correr bem, podemos testar a primeira parte com:

<code>$ java GetPid</code>
<br />

	<li>
<strong>Buscando PID a partir da classe Ruby com JRuby</strong></li>




Até agora conseguimos o processId através de JNI. Vamos agora usar o jruby para a partir de uma classe ruby 
mostrar o PID.
O primeiro passo é configurar o JRuby. Se você não fez isso ainda pode seguir por <a href="http://jruby.codehaus.org/The+JRuby+Tutorial+Part+1+-+Getting+Started">aqui</a>.

Agora vamos criar a classe JRubyGetPid.rb:
<code>require 'java'
include_class 'GetPid'
gp = GetPid.new
puts gp.getpid
</code>

O código é bem simples e agora temos as 3 linguagens interligadas via JNI e JRuby:
Ruby -&gt; Java -&gt; C

Para rodar e ver o resultado, execute:
<code>$ jruby JRubyGetPid.rb</code>

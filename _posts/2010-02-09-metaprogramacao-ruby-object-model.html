--- 
layout: post
title: "#1 Metaprograma\xC3\xA7\xC3\xA3o: Ruby Object Model"
tags: 
- "metaprograma\xC3\xA7\xC3\xA3o"
- oo
- ruby
status: publish
type: post
published: true
meta: 
  _edit_last: "597486"
---
O primeiro passo para compreender os conceitos de <strong>metaprogramação</strong> em Ruby é conhecer como a linguagem forma os objetos, ou seja, entender o fluxo de onde estão realmente os métodos e variáveis das suas classes e objetos. Esse modelo de organização é chamado <strong>Ruby Object Model</strong>.
                            
De onde veio esse método ? O que realmente ocorre ao incluir um módulo ? São perguntas que podem ser respondidas analisando o <i>modelo de objetos</i> do Ruby.

<a href="http://andersonleiteblog.files.wordpress.com/2010/02/lego.jpg"><img src="http://andersonleiteblog.files.wordpress.com/2010/02/lego.jpg" alt="" title="lego" width="400" height="297" class="aligncenter size-full wp-image-438" /></a>

<blockquote>Classes Abertas</blockquote>

Vamos analisar o seguinte problema. Precisamos de um método que, dada uma string  contendo caracteres especiais, o retorno seja a mesma string sem tais caracteres. Para facilitar a compreensão, vamos criar um test unitário e a implementação do método:    

 <a href="http://andersonleiteblog.files.wordpress.com/2010/02/picture-1.png"><img src="http://andersonleiteblog.files.wordpress.com/2010/02/picture-1.png" alt="" title="Picture 1" width="480" height="199" class="aligncenter size-full wp-image-458" /></a>
  
Funciona, porém não de uma forma muito orientada a objetos. Não é novidade que  em Ruby podemos <a href="http://andersonleiteblog.wordpress.com/2009/03/28/ruby metaprogramacao-e-convencoes/">adicionar métodos as classes em tempo de execução</a>, inclusive nas classes da biblioteca padrão do Ruby. Portanto, poderíamos adicionar nosso método diretamente na classe String:
<a href="http://andersonleiteblog.files.wordpress.com/2010/02/picture-21.png"><img src="http://andersonleiteblog.files.wordpress.com/2010/02/picture-21.png" alt="" title="Picture 2" width="480" height="224" class="aligncenter size-full wp-image-462" /></a>

Mas...o que acontece com os outros métodos da classe String ?
Agora temos duas definições para a classe String ?
Vejamos como exemplo a seguir. A classe Teste é definida duas vezes.      

<a href="http://andersonleiteblog.files.wordpress.com/2010/02/picture-111.png"><img src="http://andersonleiteblog.files.wordpress.com/2010/02/picture-111.png" alt="" title="Picture 11" width="480" height="287" class="aligncenter size-full wp-image-489" /></a>

Quando o código se refencia a classe <strong>Teste</strong> pela primeira vez, nenhuma classe existia. Então o Ruby define nesse momento a classe <strong>Teste</strong> e o <strong>método x</strong>.
Na segunda vez que a classe <strong>Teste</strong> é referenciada ela já existe, portanto o Ruby não precisa defini-la de novo. Ele apenas reabre a classe e define o <strong>método y</strong>.

É possível abrir uma classe Ruby e redefinir comporamento a qualquer momento, isso são as <strong>Classes Abertas(Open Class)</strong>, mas obviamente é necessário pensar bem antes de abrir uma classe do próprio Ruby e mudar algum comportamento.

<em>Obs: Muitas gems fazem uso dessa técnica, como o <a href="http://github.com/FooBarWidget/money">Money</a>, que insere o método to_money na classe Numeric.
</em>

<blockquote>Monkey-Patch</blockquote>

Agora suponha que você tem um Array de Strings. Nesse array você deseja procurar  todas as palavras "verde" e substituí-las por "azul". Nessa caso você poderia definir um método chamado replace:

<a href="http://andersonleiteblog.files.wordpress.com/2010/02/picture-10.png"><img src="http://andersonleiteblog.files.wordpress.com/2010/02/picture-10.png" alt="" title="Picture 10" width="480" height="280" class="aligncenter size-full wp-image-484" /></a>                          

Funciona, porém olhe os métodos já existentes na classe Array:
<a href="http://andersonleiteblog.files.wordpress.com/2010/02/picture-5.png"><img src="http://andersonleiteblog.files.wordpress.com/2010/02/picture-5.png" alt="" title="Picture 5" width="480" height="36" class="aligncenter size-full wp-image-467" /></a>

Esse é o lado complicado de classes abertas, também conhecido como monkey-patch. Você pode mudar o comportamento de outros arrays que utilizavam o método replace. Existem prós e contras na utilização de monkey patch, ou seja, devem ser utilizados corretamente.

<a href="http://andersonleiteblog.files.wordpress.com/2010/02/monkey.jpg"><img src="http://andersonleiteblog.files.wordpress.com/2010/02/monkey.jpg" alt="" title="monkey" width="480" height="360" class="aligncenter size-full wp-image-439" /></a>

<blockquote>Objetos</blockquote>

Veja a classe abaixo:

<a href="http://andersonleiteblog.files.wordpress.com/2010/02/picture-6.png"><img src="http://andersonleiteblog.files.wordpress.com/2010/02/picture-6.png" alt="" title="Picture 6" width="480" height="241" class="aligncenter size-full wp-image-468" /></a>          
Em Ruby <strong>não existe conexão entre a classe de um objeto e suas variáveis de instância</strong>. Isso significa que se o método <b>my_method</b> não for chamado o objeto não teria essa variável.

O importante aqui é: <strong>Variáveis de instância vivem nos objetos enquanto métodos vivem nas classes</strong>. O método <b>my_method</b> é um método de instância de MyClass(e não apenas um método), o que significa que ele foi definido em <b>MyClass</b> e para chamá-lo você precisa de uma instância de <b>MyClass</b>.                         

Veja outro exemplo:

<a href="http://andersonleiteblog.files.wordpress.com/2010/02/picture-71.png"><img src="http://andersonleiteblog.files.wordpress.com/2010/02/picture-71.png" alt="" title="Picture 7" width="480" height="58" class="aligncenter size-full wp-image-471" /></a>

Perceba que os métodos que podem ser chamados na instância "abc" <strong>são os mesmos</strong> obtido pelo método <b>instance_methods</b> diretamente na classe String. Porém os métodos que você pode chamar em uma instância como "abc" <strong>não são os mesmos</strong> que pode chamar na classe String.             

<blockquote>Lookup e Execution</blockquote>
                  
Para entender a chamada de métodos no Ruby precisamos compreender duas fases.
<strong>Object em Ruby é a superclass de todas as classes</strong> (ou BasicObject a partir do Ruby 1.9).

Quase todo objeto possui <strong>uma classe e superclasse</strong>. Na classe descobrimos quais métodos de instância podem ser chamados. Nas superclasses herdamos outros métodos. Vejamos as classes abaixo:

<a href="http://andersonleiteblog.files.wordpress.com/2010/02/picture-8.png"><img src="http://andersonleiteblog.files.wordpress.com/2010/02/picture-8.png" alt="" title="Picture 8" width="480" height="259" class="aligncenter size-full wp-image-472" /></a>

Com isso chegamos em um diagrama bem interessante sobre o <strong>Ruby Object Model</strong>:
<a href="http://andersonleiteblog.files.wordpress.com/2010/02/model.png"><img src="http://andersonleiteblog.files.wordpress.com/2010/02/model.png" alt="" title="model" width="480" height="307" class="aligncenter size-full wp-image-453" /></a>
                                 
<blockquote>Method Lookup</blockquote>

A primeira coisa para descobrir de onde vem um método no objeto Ruby é fazer analisar sua classe e subir por suas superclasses. Essa estratégia é conhecida como "<em><strong>one step to the right, then up</strong></em>”.

Para entender esse conceito de cadeias na chamada de métodos, percorra a classe e suas subclasses, pode-se usar o método <i>ancestors</i> para isso, até chegar em Object e BasicObject.

<a href="http://andersonleiteblog.files.wordpress.com/2010/02/picture-9.png"><img src="http://andersonleiteblog.files.wordpress.com/2010/02/picture-9.png" alt="" title="Picture 9" width="480" height="37" class="aligncenter size-full wp-image-473" /></a>
                             
<strong>Módulos</strong>

Repare que aparece o módulo <strong>Kernel</strong> logo após <strong>Object</strong>. Por quê? Toda vez que  uma classe inclui um módulo ela entra na corrente logo após a classe que a  incluiu. Muitas gems tiram vantagens disso incluindo métodos no módulo <strong>Kernel</strong>.
(<a href="http://github.com/dchelimsky/rspec/blob/master/lib/spec/expectations/extensions/kernel.rb">O RSpec, por exemplo, que inclui should e should_not em todos os objetos</a>)

<blockquote>Metaprogramação - Continua ...</blockquote>
Conhecer sobre o modelo de objetos ruby é obrigatório para entender metaprogramação. Esse post ainda poderia ir muito longe em questões como receiver, self, method execution, etc, assuntos que serão tratados em próximos posts.

<strong>Continua</strong>
Próximo post - <a href="http://andersonleiteblog.wordpress.com/2010/02/10/metaprogramacao-definindo-metodos/">Definindo métodos</a>
